// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: VCCSim.proto

#include "VCCSim.pb.h"
#include "VCCSim.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace VCCSim {

static const char* LidarService_method_names[] = {
  "/VCCSim.LidarService/GetLiDARData",
  "/VCCSim.LidarService/GetLiDAROdom",
  "/VCCSim.LidarService/GetLiDARDataAndOdom",
};

std::unique_ptr< LidarService::Stub> LidarService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< LidarService::Stub> stub(new LidarService::Stub(channel, options));
  return stub;
}

LidarService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetLiDARData_(LidarService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetLiDAROdom_(LidarService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetLiDARDataAndOdom_(LidarService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status LidarService::Stub::GetLiDARData(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::LidarData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDARData_, context, request, response);
}

void LidarService::Stub::async::GetLiDARData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARData_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDARData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::LidarData>* LidarService::Stub::PrepareAsyncGetLiDARDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::LidarData, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDARData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::LidarData>* LidarService::Stub::AsyncGetLiDARDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDARDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status LidarService::Stub::GetLiDAROdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDAROdom_, context, request, response);
}

void LidarService::Stub::async::GetLiDAROdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDAROdom_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDAROdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDAROdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* LidarService::Stub::PrepareAsyncGetLiDAROdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDAROdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* LidarService::Stub::AsyncGetLiDAROdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDAROdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status LidarService::Stub::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::LidarDataAndOdom* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDARDataAndOdom_, context, request, response);
}

void LidarService::Stub::async::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarDataAndOdom* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARDataAndOdom_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarDataAndOdom* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARDataAndOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::LidarDataAndOdom>* LidarService::Stub::PrepareAsyncGetLiDARDataAndOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::LidarDataAndOdom, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDARDataAndOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::LidarDataAndOdom>* LidarService::Stub::AsyncGetLiDARDataAndOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDARDataAndOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

LidarService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::VCCSim::RobotName, ::VCCSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::LidarData* resp) {
               return service->GetLiDARData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetLiDAROdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::VCCSim::RobotName, ::VCCSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::LidarDataAndOdom* resp) {
               return service->GetLiDARDataAndOdom(ctx, req, resp);
             }, this)));
}

LidarService::Service::~Service() {
}

::grpc::Status LidarService::Service::GetLiDARData(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LidarService::Service::GetLiDAROdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LidarService::Service::GetLiDARDataAndOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarDataAndOdom* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DepthCameraService_method_names[] = {
  "/VCCSim.DepthCameraService/GetDepthCameraPointData",
  "/VCCSim.DepthCameraService/GetDepthCameraImageSize",
  "/VCCSim.DepthCameraService/GetDepthCameraImageData",
  "/VCCSim.DepthCameraService/GetDepthCameraOdom",
};

std::unique_ptr< DepthCameraService::Stub> DepthCameraService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DepthCameraService::Stub> stub(new DepthCameraService::Stub(channel, options));
  return stub;
}

DepthCameraService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetDepthCameraPointData_(DepthCameraService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetDepthCameraImageSize_(DepthCameraService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetDepthCameraImageData_(DepthCameraService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetDepthCameraOdom_(DepthCameraService_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DepthCameraService::Stub::GetDepthCameraPointData(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::DepthCameraPointData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraPointData_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraPointData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraPointData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraPointData_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraPointData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraPointData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraPointData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::DepthCameraPointData>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraPointDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::DepthCameraPointData, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraPointData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::DepthCameraPointData>* DepthCameraService::Stub::AsyncGetDepthCameraPointDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraPointDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DepthCameraService::Stub::GetDepthCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::ImageSize* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraImageSize_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::ImageSize* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraImageSize_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::ImageSize* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraImageSize_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::ImageSize>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraImageSizeRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::ImageSize, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraImageSize_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::ImageSize>* DepthCameraService::Stub::AsyncGetDepthCameraImageSizeRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraImageSizeRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DepthCameraService::Stub::GetDepthCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::DepthCameraImageData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraImageData_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraImageData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraImageData_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraImageData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraImageData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::DepthCameraImageData>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::DepthCameraImageData, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraImageData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::DepthCameraImageData>* DepthCameraService::Stub::AsyncGetDepthCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraImageDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DepthCameraService::Stub::GetDepthCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraOdom_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraOdom_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* DepthCameraService::Stub::AsyncGetDepthCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

DepthCameraService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::VCCSim::RobotName, ::VCCSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::DepthCameraPointData* resp) {
               return service->GetDepthCameraPointData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::VCCSim::RobotName, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::ImageSize* resp) {
               return service->GetDepthCameraImageSize(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::VCCSim::RobotName, ::VCCSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::DepthCameraImageData* resp) {
               return service->GetDepthCameraImageData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetDepthCameraOdom(ctx, req, resp);
             }, this)));
}

DepthCameraService::Service::~Service() {
}

::grpc::Status DepthCameraService::Service::GetDepthCameraPointData(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraPointData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DepthCameraService::Service::GetDepthCameraImageSize(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::ImageSize* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DepthCameraService::Service::GetDepthCameraImageData(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraImageData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DepthCameraService::Service::GetDepthCameraOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* RGBCameraService_method_names[] = {
  "/VCCSim.RGBCameraService/GetRGBCameraOdom",
  "/VCCSim.RGBCameraService/GetRGBIndexedCameraImageData",
  "/VCCSim.RGBCameraService/GetRGBIndexedCameraImageSize",
};

std::unique_ptr< RGBCameraService::Stub> RGBCameraService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< RGBCameraService::Stub> stub(new RGBCameraService::Stub(channel, options));
  return stub;
}

RGBCameraService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetRGBCameraOdom_(RGBCameraService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetRGBIndexedCameraImageData_(RGBCameraService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetRGBIndexedCameraImageSize_(RGBCameraService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status RGBCameraService::Stub::GetRGBCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetRGBCameraOdom_, context, request, response);
}

void RGBCameraService::Stub::async::GetRGBCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBCameraOdom_, context, request, response, std::move(f));
}

void RGBCameraService::Stub::async::GetRGBCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBCameraOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* RGBCameraService::Stub::PrepareAsyncGetRGBCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetRGBCameraOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* RGBCameraService::Stub::AsyncGetRGBCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetRGBCameraOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RGBCameraService::Stub::GetRGBIndexedCameraImageData(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::VCCSim::RGBCameraImageData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::IndexedCamera, ::VCCSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetRGBIndexedCameraImageData_, context, request, response);
}

void RGBCameraService::Stub::async::GetRGBIndexedCameraImageData(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::RGBCameraImageData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::IndexedCamera, ::VCCSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBIndexedCameraImageData_, context, request, response, std::move(f));
}

void RGBCameraService::Stub::async::GetRGBIndexedCameraImageData(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::RGBCameraImageData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBIndexedCameraImageData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::RGBCameraImageData>* RGBCameraService::Stub::PrepareAsyncGetRGBIndexedCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::RGBCameraImageData, ::VCCSim::IndexedCamera, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetRGBIndexedCameraImageData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::RGBCameraImageData>* RGBCameraService::Stub::AsyncGetRGBIndexedCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetRGBIndexedCameraImageDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RGBCameraService::Stub::GetRGBIndexedCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::VCCSim::ImageSize* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::IndexedCamera, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetRGBIndexedCameraImageSize_, context, request, response);
}

void RGBCameraService::Stub::async::GetRGBIndexedCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::ImageSize* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::IndexedCamera, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBIndexedCameraImageSize_, context, request, response, std::move(f));
}

void RGBCameraService::Stub::async::GetRGBIndexedCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::ImageSize* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBIndexedCameraImageSize_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::ImageSize>* RGBCameraService::Stub::PrepareAsyncGetRGBIndexedCameraImageSizeRaw(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::ImageSize, ::VCCSim::IndexedCamera, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetRGBIndexedCameraImageSize_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::ImageSize>* RGBCameraService::Stub::AsyncGetRGBIndexedCameraImageSizeRaw(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetRGBIndexedCameraImageSizeRaw(context, request, cq);
  result->StartCall();
  return result;
}

RGBCameraService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RGBCameraService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RGBCameraService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RGBCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetRGBCameraOdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RGBCameraService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RGBCameraService::Service, ::VCCSim::IndexedCamera, ::VCCSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RGBCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::IndexedCamera* req,
             ::VCCSim::RGBCameraImageData* resp) {
               return service->GetRGBIndexedCameraImageData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RGBCameraService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RGBCameraService::Service, ::VCCSim::IndexedCamera, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RGBCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::IndexedCamera* req,
             ::VCCSim::ImageSize* resp) {
               return service->GetRGBIndexedCameraImageSize(ctx, req, resp);
             }, this)));
}

RGBCameraService::Service::~Service() {
}

::grpc::Status RGBCameraService::Service::GetRGBCameraOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RGBCameraService::Service::GetRGBIndexedCameraImageData(::grpc::ServerContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::RGBCameraImageData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RGBCameraService::Service::GetRGBIndexedCameraImageSize(::grpc::ServerContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::ImageSize* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* SegmentationCameraService_method_names[] = {
  "/VCCSim.SegmentationCameraService/GetSegmentationCameraOdom",
  "/VCCSim.SegmentationCameraService/GetSegmentationCameraImageData",
  "/VCCSim.SegmentationCameraService/GetSegmentationCameraImageSize",
};

std::unique_ptr< SegmentationCameraService::Stub> SegmentationCameraService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< SegmentationCameraService::Stub> stub(new SegmentationCameraService::Stub(channel, options));
  return stub;
}

SegmentationCameraService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetSegmentationCameraOdom_(SegmentationCameraService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetSegmentationCameraImageData_(SegmentationCameraService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetSegmentationCameraImageSize_(SegmentationCameraService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status SegmentationCameraService::Stub::GetSegmentationCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetSegmentationCameraOdom_, context, request, response);
}

void SegmentationCameraService::Stub::async::GetSegmentationCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetSegmentationCameraOdom_, context, request, response, std::move(f));
}

void SegmentationCameraService::Stub::async::GetSegmentationCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetSegmentationCameraOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* SegmentationCameraService::Stub::PrepareAsyncGetSegmentationCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetSegmentationCameraOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* SegmentationCameraService::Stub::AsyncGetSegmentationCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetSegmentationCameraOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status SegmentationCameraService::Stub::GetSegmentationCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::SegmentationCameraImageData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::SegmentationCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetSegmentationCameraImageData_, context, request, response);
}

void SegmentationCameraService::Stub::async::GetSegmentationCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::SegmentationCameraImageData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::SegmentationCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetSegmentationCameraImageData_, context, request, response, std::move(f));
}

void SegmentationCameraService::Stub::async::GetSegmentationCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::SegmentationCameraImageData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetSegmentationCameraImageData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::SegmentationCameraImageData>* SegmentationCameraService::Stub::PrepareAsyncGetSegmentationCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::SegmentationCameraImageData, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetSegmentationCameraImageData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::SegmentationCameraImageData>* SegmentationCameraService::Stub::AsyncGetSegmentationCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetSegmentationCameraImageDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status SegmentationCameraService::Stub::GetSegmentationCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::ImageSize* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetSegmentationCameraImageSize_, context, request, response);
}

void SegmentationCameraService::Stub::async::GetSegmentationCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::ImageSize* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetSegmentationCameraImageSize_, context, request, response, std::move(f));
}

void SegmentationCameraService::Stub::async::GetSegmentationCameraImageSize(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::ImageSize* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetSegmentationCameraImageSize_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::ImageSize>* SegmentationCameraService::Stub::PrepareAsyncGetSegmentationCameraImageSizeRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::ImageSize, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetSegmentationCameraImageSize_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::ImageSize>* SegmentationCameraService::Stub::AsyncGetSegmentationCameraImageSizeRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetSegmentationCameraImageSizeRaw(context, request, cq);
  result->StartCall();
  return result;
}

SegmentationCameraService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SegmentationCameraService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SegmentationCameraService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](SegmentationCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetSegmentationCameraOdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SegmentationCameraService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SegmentationCameraService::Service, ::VCCSim::RobotName, ::VCCSim::SegmentationCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](SegmentationCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::SegmentationCameraImageData* resp) {
               return service->GetSegmentationCameraImageData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SegmentationCameraService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SegmentationCameraService::Service, ::VCCSim::RobotName, ::VCCSim::ImageSize, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](SegmentationCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::ImageSize* resp) {
               return service->GetSegmentationCameraImageSize(ctx, req, resp);
             }, this)));
}

SegmentationCameraService::Service::~Service() {
}

::grpc::Status SegmentationCameraService::Service::GetSegmentationCameraOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SegmentationCameraService::Service::GetSegmentationCameraImageData(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::SegmentationCameraImageData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SegmentationCameraService::Service::GetSegmentationCameraImageSize(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::ImageSize* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DroneService_method_names[] = {
  "/VCCSim.DroneService/GetDronePose",
  "/VCCSim.DroneService/SendDronePose",
  "/VCCSim.DroneService/SendDronePath",
};

std::unique_ptr< DroneService::Stub> DroneService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DroneService::Stub> stub(new DroneService::Stub(channel, options));
  return stub;
}

DroneService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetDronePose_(DroneService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendDronePose_(DroneService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendDronePath_(DroneService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DroneService::Stub::GetDronePose(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Pose* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDronePose_, context, request, response);
}

void DroneService::Stub::async::GetDronePose(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDronePose_, context, request, response, std::move(f));
}

void DroneService::Stub::async::GetDronePose(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDronePose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Pose>* DroneService::Stub::PrepareAsyncGetDronePoseRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Pose, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDronePose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Pose>* DroneService::Stub::AsyncGetDronePoseRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDronePoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DroneService::Stub::SendDronePose(::grpc::ClientContext* context, const ::VCCSim::DronePose& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::DronePose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendDronePose_, context, request, response);
}

void DroneService::Stub::async::SendDronePose(::grpc::ClientContext* context, const ::VCCSim::DronePose* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::DronePose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePose_, context, request, response, std::move(f));
}

void DroneService::Stub::async::SendDronePose(::grpc::ClientContext* context, const ::VCCSim::DronePose* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* DroneService::Stub::PrepareAsyncSendDronePoseRaw(::grpc::ClientContext* context, const ::VCCSim::DronePose& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::DronePose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendDronePose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* DroneService::Stub::AsyncSendDronePoseRaw(::grpc::ClientContext* context, const ::VCCSim::DronePose& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendDronePoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DroneService::Stub::SendDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendDronePath_, context, request, response);
}

void DroneService::Stub::async::SendDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePath_, context, request, response, std::move(f));
}

void DroneService::Stub::async::SendDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePath_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* DroneService::Stub::PrepareAsyncSendDronePathRaw(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::DronePath, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendDronePath_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* DroneService::Stub::AsyncSendDronePathRaw(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendDronePathRaw(context, request, cq);
  result->StartCall();
  return result;
}

DroneService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DroneService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DroneService::Service, ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DroneService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Pose* resp) {
               return service->GetDronePose(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DroneService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DroneService::Service, ::VCCSim::DronePose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DroneService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::DronePose* req,
             ::VCCSim::Status* resp) {
               return service->SendDronePose(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DroneService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DroneService::Service, ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DroneService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::DronePath* req,
             ::VCCSim::Status* resp) {
               return service->SendDronePath(ctx, req, resp);
             }, this)));
}

DroneService::Service::~Service() {
}

::grpc::Status DroneService::Service::GetDronePose(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DroneService::Service::SendDronePose(::grpc::ServerContext* context, const ::VCCSim::DronePose* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DroneService::Service::SendDronePath(::grpc::ServerContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* CarService_method_names[] = {
  "/VCCSim.CarService/GetCarOdom",
  "/VCCSim.CarService/SendCarPose",
  "/VCCSim.CarService/SendCarPath",
};

std::unique_ptr< CarService::Stub> CarService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< CarService::Stub> stub(new CarService::Stub(channel, options));
  return stub;
}

CarService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetCarOdom_(CarService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendCarPose_(CarService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendCarPath_(CarService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status CarService::Stub::GetCarOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetCarOdom_, context, request, response);
}

void CarService::Stub::async::GetCarOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetCarOdom_, context, request, response, std::move(f));
}

void CarService::Stub::async::GetCarOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetCarOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* CarService::Stub::PrepareAsyncGetCarOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetCarOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* CarService::Stub::AsyncGetCarOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetCarOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CarService::Stub::SendCarPose(::grpc::ClientContext* context, const ::VCCSim::CarPose& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::CarPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendCarPose_, context, request, response);
}

void CarService::Stub::async::SendCarPose(::grpc::ClientContext* context, const ::VCCSim::CarPose* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::CarPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPose_, context, request, response, std::move(f));
}

void CarService::Stub::async::SendCarPose(::grpc::ClientContext* context, const ::VCCSim::CarPose* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* CarService::Stub::PrepareAsyncSendCarPoseRaw(::grpc::ClientContext* context, const ::VCCSim::CarPose& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::CarPose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendCarPose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* CarService::Stub::AsyncSendCarPoseRaw(::grpc::ClientContext* context, const ::VCCSim::CarPose& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendCarPoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CarService::Stub::SendCarPath(::grpc::ClientContext* context, const ::VCCSim::CarPath& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::CarPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendCarPath_, context, request, response);
}

void CarService::Stub::async::SendCarPath(::grpc::ClientContext* context, const ::VCCSim::CarPath* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::CarPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPath_, context, request, response, std::move(f));
}

void CarService::Stub::async::SendCarPath(::grpc::ClientContext* context, const ::VCCSim::CarPath* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPath_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* CarService::Stub::PrepareAsyncSendCarPathRaw(::grpc::ClientContext* context, const ::VCCSim::CarPath& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::CarPath, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendCarPath_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* CarService::Stub::AsyncSendCarPathRaw(::grpc::ClientContext* context, const ::VCCSim::CarPath& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendCarPathRaw(context, request, cq);
  result->StartCall();
  return result;
}

CarService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CarService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CarService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetCarOdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CarService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CarService::Service, ::VCCSim::CarPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::CarPose* req,
             ::VCCSim::Status* resp) {
               return service->SendCarPose(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CarService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CarService::Service, ::VCCSim::CarPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::CarPath* req,
             ::VCCSim::Status* resp) {
               return service->SendCarPath(ctx, req, resp);
             }, this)));
}

CarService::Service::~Service() {
}

::grpc::Status CarService::Service::GetCarOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CarService::Service::SendCarPose(::grpc::ServerContext* context, const ::VCCSim::CarPose* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CarService::Service::SendCarPath(::grpc::ServerContext* context, const ::VCCSim::CarPath* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* FlashService_method_names[] = {
  "/VCCSim.FlashService/GetFlashPose",
  "/VCCSim.FlashService/SendFlashPose",
  "/VCCSim.FlashService/SendFlashPath",
  "/VCCSim.FlashService/CheckFlashReady",
  "/VCCSim.FlashService/MoveToNext",
};

std::unique_ptr< FlashService::Stub> FlashService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< FlashService::Stub> stub(new FlashService::Stub(channel, options));
  return stub;
}

FlashService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetFlashPose_(FlashService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendFlashPose_(FlashService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendFlashPath_(FlashService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CheckFlashReady_(FlashService_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MoveToNext_(FlashService_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status FlashService::Stub::GetFlashPose(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Pose* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetFlashPose_, context, request, response);
}

void FlashService::Stub::async::GetFlashPose(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetFlashPose_, context, request, response, std::move(f));
}

void FlashService::Stub::async::GetFlashPose(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetFlashPose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Pose>* FlashService::Stub::PrepareAsyncGetFlashPoseRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Pose, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetFlashPose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Pose>* FlashService::Stub::AsyncGetFlashPoseRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetFlashPoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status FlashService::Stub::SendFlashPose(::grpc::ClientContext* context, const ::VCCSim::FlashPose& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::FlashPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendFlashPose_, context, request, response);
}

void FlashService::Stub::async::SendFlashPose(::grpc::ClientContext* context, const ::VCCSim::FlashPose* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::FlashPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendFlashPose_, context, request, response, std::move(f));
}

void FlashService::Stub::async::SendFlashPose(::grpc::ClientContext* context, const ::VCCSim::FlashPose* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendFlashPose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* FlashService::Stub::PrepareAsyncSendFlashPoseRaw(::grpc::ClientContext* context, const ::VCCSim::FlashPose& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::FlashPose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendFlashPose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* FlashService::Stub::AsyncSendFlashPoseRaw(::grpc::ClientContext* context, const ::VCCSim::FlashPose& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendFlashPoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status FlashService::Stub::SendFlashPath(::grpc::ClientContext* context, const ::VCCSim::FlashPath& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::FlashPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendFlashPath_, context, request, response);
}

void FlashService::Stub::async::SendFlashPath(::grpc::ClientContext* context, const ::VCCSim::FlashPath* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::FlashPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendFlashPath_, context, request, response, std::move(f));
}

void FlashService::Stub::async::SendFlashPath(::grpc::ClientContext* context, const ::VCCSim::FlashPath* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendFlashPath_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* FlashService::Stub::PrepareAsyncSendFlashPathRaw(::grpc::ClientContext* context, const ::VCCSim::FlashPath& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::FlashPath, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendFlashPath_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* FlashService::Stub::AsyncSendFlashPathRaw(::grpc::ClientContext* context, const ::VCCSim::FlashPath& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendFlashPathRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status FlashService::Stub::CheckFlashReady(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_CheckFlashReady_, context, request, response);
}

void FlashService::Stub::async::CheckFlashReady(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CheckFlashReady_, context, request, response, std::move(f));
}

void FlashService::Stub::async::CheckFlashReady(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CheckFlashReady_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* FlashService::Stub::PrepareAsyncCheckFlashReadyRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CheckFlashReady_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* FlashService::Stub::AsyncCheckFlashReadyRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCheckFlashReadyRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status FlashService::Stub::MoveToNext(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MoveToNext_, context, request, response);
}

void FlashService::Stub::async::MoveToNext(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MoveToNext_, context, request, response, std::move(f));
}

void FlashService::Stub::async::MoveToNext(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MoveToNext_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* FlashService::Stub::PrepareAsyncMoveToNextRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MoveToNext_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* FlashService::Stub::AsyncMoveToNextRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMoveToNextRaw(context, request, cq);
  result->StartCall();
  return result;
}

FlashService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      FlashService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< FlashService::Service, ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](FlashService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Pose* resp) {
               return service->GetFlashPose(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      FlashService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< FlashService::Service, ::VCCSim::FlashPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](FlashService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::FlashPose* req,
             ::VCCSim::Status* resp) {
               return service->SendFlashPose(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      FlashService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< FlashService::Service, ::VCCSim::FlashPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](FlashService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::FlashPath* req,
             ::VCCSim::Status* resp) {
               return service->SendFlashPath(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      FlashService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< FlashService::Service, ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](FlashService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Status* resp) {
               return service->CheckFlashReady(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      FlashService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< FlashService::Service, ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](FlashService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Status* resp) {
               return service->MoveToNext(ctx, req, resp);
             }, this)));
}

FlashService::Service::~Service() {
}

::grpc::Status FlashService::Service::GetFlashPose(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status FlashService::Service::SendFlashPose(::grpc::ServerContext* context, const ::VCCSim::FlashPose* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status FlashService::Service::SendFlashPath(::grpc::ServerContext* context, const ::VCCSim::FlashPath* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status FlashService::Service::CheckFlashReady(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status FlashService::Service::MoveToNext(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* MeshService_method_names[] = {
  "/VCCSim.MeshService/SendMesh",
  "/VCCSim.MeshService/SendGlobalMesh",
  "/VCCSim.MeshService/RemoveGlobalMesh",
};

std::unique_ptr< MeshService::Stub> MeshService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< MeshService::Stub> stub(new MeshService::Stub(channel, options));
  return stub;
}

MeshService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_SendMesh_(MeshService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendGlobalMesh_(MeshService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_RemoveGlobalMesh_(MeshService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status MeshService::Stub::SendMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::MeshData, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendMesh_, context, request, response);
}

void MeshService::Stub::async::SendMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::MeshData, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendMesh_, context, request, response, std::move(f));
}

void MeshService::Stub::async::SendMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendMesh_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* MeshService::Stub::PrepareAsyncSendMeshRaw(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::MeshData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendMesh_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* MeshService::Stub::AsyncSendMeshRaw(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendMeshRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status MeshService::Stub::SendGlobalMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::VCCSim::MeshID* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::MeshData, ::VCCSim::MeshID, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendGlobalMesh_, context, request, response);
}

void MeshService::Stub::async::SendGlobalMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData* request, ::VCCSim::MeshID* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::MeshData, ::VCCSim::MeshID, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendGlobalMesh_, context, request, response, std::move(f));
}

void MeshService::Stub::async::SendGlobalMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData* request, ::VCCSim::MeshID* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendGlobalMesh_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::MeshID>* MeshService::Stub::PrepareAsyncSendGlobalMeshRaw(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::MeshID, ::VCCSim::MeshData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendGlobalMesh_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::MeshID>* MeshService::Stub::AsyncSendGlobalMeshRaw(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendGlobalMeshRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status MeshService::Stub::RemoveGlobalMesh(::grpc::ClientContext* context, const ::VCCSim::MeshID& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::MeshID, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_RemoveGlobalMesh_, context, request, response);
}

void MeshService::Stub::async::RemoveGlobalMesh(::grpc::ClientContext* context, const ::VCCSim::MeshID* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::MeshID, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RemoveGlobalMesh_, context, request, response, std::move(f));
}

void MeshService::Stub::async::RemoveGlobalMesh(::grpc::ClientContext* context, const ::VCCSim::MeshID* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RemoveGlobalMesh_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* MeshService::Stub::PrepareAsyncRemoveGlobalMeshRaw(::grpc::ClientContext* context, const ::VCCSim::MeshID& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::MeshID, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_RemoveGlobalMesh_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* MeshService::Stub::AsyncRemoveGlobalMeshRaw(::grpc::ClientContext* context, const ::VCCSim::MeshID& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRemoveGlobalMeshRaw(context, request, cq);
  result->StartCall();
  return result;
}

MeshService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MeshService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MeshService::Service, ::VCCSim::MeshData, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MeshService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::MeshData* req,
             ::VCCSim::Status* resp) {
               return service->SendMesh(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MeshService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MeshService::Service, ::VCCSim::MeshData, ::VCCSim::MeshID, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MeshService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::MeshData* req,
             ::VCCSim::MeshID* resp) {
               return service->SendGlobalMesh(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MeshService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MeshService::Service, ::VCCSim::MeshID, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MeshService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::MeshID* req,
             ::VCCSim::Status* resp) {
               return service->RemoveGlobalMesh(ctx, req, resp);
             }, this)));
}

MeshService::Service::~Service() {
}

::grpc::Status MeshService::Service::SendMesh(::grpc::ServerContext* context, const ::VCCSim::MeshData* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status MeshService::Service::SendGlobalMesh(::grpc::ServerContext* context, const ::VCCSim::MeshData* request, ::VCCSim::MeshID* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status MeshService::Service::RemoveGlobalMesh(::grpc::ServerContext* context, const ::VCCSim::MeshID* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* PointCloudService_method_names[] = {
  "/VCCSim.PointCloudService/SendPointCloudWithColor",
};

std::unique_ptr< PointCloudService::Stub> PointCloudService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< PointCloudService::Stub> stub(new PointCloudService::Stub(channel, options));
  return stub;
}

PointCloudService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_SendPointCloudWithColor_(PointCloudService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status PointCloudService::Stub::SendPointCloudWithColor(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::PointCloudWithColor, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendPointCloudWithColor_, context, request, response);
}

void PointCloudService::Stub::async::SendPointCloudWithColor(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::PointCloudWithColor, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendPointCloudWithColor_, context, request, response, std::move(f));
}

void PointCloudService::Stub::async::SendPointCloudWithColor(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendPointCloudWithColor_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* PointCloudService::Stub::PrepareAsyncSendPointCloudWithColorRaw(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::PointCloudWithColor, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendPointCloudWithColor_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* PointCloudService::Stub::AsyncSendPointCloudWithColorRaw(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendPointCloudWithColorRaw(context, request, cq);
  result->StartCall();
  return result;
}

PointCloudService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      PointCloudService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< PointCloudService::Service, ::VCCSim::PointCloudWithColor, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](PointCloudService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::PointCloudWithColor* req,
             ::VCCSim::Status* resp) {
               return service->SendPointCloudWithColor(ctx, req, resp);
             }, this)));
}

PointCloudService::Service::~Service() {
}

::grpc::Status PointCloudService::Service::SendPointCloudWithColor(::grpc::ServerContext* context, const ::VCCSim::PointCloudWithColor* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* SafeCheckService_method_names[] = {
  "/VCCSim.SafeCheckService/CheckSafetyPawn",
  "/VCCSim.SafeCheckService/CheckSafetyPosition",
  "/VCCSim.SafeCheckService/CheckSafetyDronePath",
};

std::unique_ptr< SafeCheckService::Stub> SafeCheckService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< SafeCheckService::Stub> stub(new SafeCheckService::Stub(channel, options));
  return stub;
}

SafeCheckService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_CheckSafetyPawn_(SafeCheckService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CheckSafetyPosition_(SafeCheckService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CheckSafetyDronePath_(SafeCheckService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status SafeCheckService::Stub::CheckSafetyPawn(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_CheckSafetyPawn_, context, request, response);
}

void SafeCheckService::Stub::async::CheckSafetyPawn(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CheckSafetyPawn_, context, request, response, std::move(f));
}

void SafeCheckService::Stub::async::CheckSafetyPawn(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CheckSafetyPawn_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* SafeCheckService::Stub::PrepareAsyncCheckSafetyPawnRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CheckSafetyPawn_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* SafeCheckService::Stub::AsyncCheckSafetyPawnRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCheckSafetyPawnRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status SafeCheckService::Stub::CheckSafetyPosition(::grpc::ClientContext* context, const ::VCCSim::Position& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::Position, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_CheckSafetyPosition_, context, request, response);
}

void SafeCheckService::Stub::async::CheckSafetyPosition(::grpc::ClientContext* context, const ::VCCSim::Position* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::Position, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CheckSafetyPosition_, context, request, response, std::move(f));
}

void SafeCheckService::Stub::async::CheckSafetyPosition(::grpc::ClientContext* context, const ::VCCSim::Position* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CheckSafetyPosition_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* SafeCheckService::Stub::PrepareAsyncCheckSafetyPositionRaw(::grpc::ClientContext* context, const ::VCCSim::Position& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::Position, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CheckSafetyPosition_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* SafeCheckService::Stub::AsyncCheckSafetyPositionRaw(::grpc::ClientContext* context, const ::VCCSim::Position& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCheckSafetyPositionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status SafeCheckService::Stub::CheckSafetyDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_CheckSafetyDronePath_, context, request, response);
}

void SafeCheckService::Stub::async::CheckSafetyDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CheckSafetyDronePath_, context, request, response, std::move(f));
}

void SafeCheckService::Stub::async::CheckSafetyDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CheckSafetyDronePath_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* SafeCheckService::Stub::PrepareAsyncCheckSafetyDronePathRaw(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::DronePath, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CheckSafetyDronePath_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* SafeCheckService::Stub::AsyncCheckSafetyDronePathRaw(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCheckSafetyDronePathRaw(context, request, cq);
  result->StartCall();
  return result;
}

SafeCheckService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SafeCheckService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SafeCheckService::Service, ::VCCSim::RobotName, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](SafeCheckService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Status* resp) {
               return service->CheckSafetyPawn(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SafeCheckService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SafeCheckService::Service, ::VCCSim::Position, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](SafeCheckService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::Position* req,
             ::VCCSim::Status* resp) {
               return service->CheckSafetyPosition(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SafeCheckService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SafeCheckService::Service, ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](SafeCheckService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::DronePath* req,
             ::VCCSim::Status* resp) {
               return service->CheckSafetyDronePath(ctx, req, resp);
             }, this)));
}

SafeCheckService::Service::~Service() {
}

::grpc::Status SafeCheckService::Service::CheckSafetyPawn(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SafeCheckService::Service::CheckSafetyPosition(::grpc::ServerContext* context, const ::VCCSim::Position* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SafeCheckService::Service::CheckSafetyDronePath(::grpc::ServerContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace VCCSim

